---
title: "DATA119 - Data Visualization"
output: 
  learnr::tutorial:
    css: css/custom-styles.css
runtime: shiny_prerendered
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(error = TRUE)
knitr::knit_engines$set(python = reticulate::eng_python)

library(learnr)
library(gradethis)
library(reticulate)

# Set the path to the existing Python environment
#reticulate::use_python("/opt/python/3.9.21/bin/python", required = TRUE)

# Optional: Install necessary Python packages if not already installed
#reticulate::py_install(c('numpy', 'pandas', 'plotnine', 'seaborn', 'altair', 'matplotlib'))

custom_checker <- function(label, user_code, solution_code, envir_result, evaluate_result, last_value, stage, ...) {
  if (stage == "code_check") {
      if (user_code == solution_code){
          return(list(message = random_praise(), correct = TRUE))
      }
    return(list(message = random_encouragement(), correct = FALSE))
  }
}

gradethis_setup()
tutorial_options(exercise.completion = FALSE, exercise.checker = custom_checker)
```

```{r header, echo = FALSE}
library(htmltools)

tags$div(
  class = "topContainer",
  tags$div(
    class = "logoAndTitle",
    tags$img(
      src = "./images/dsi_logo.png",
      alt = "DSI Logo",
      class = "topLogo"
    ),
    tags$h1("Data Visualization", class = "pageTitle")
  )
)
```

## Goals

The goals of this lab are:

* To understand the basic theory underpinning the field of data visualization.
* To learn which visualizations are best suited to which use cases
* To practice using matplotlib to make visualizations
* To get exposure to seaborn, plotnine, plotly, and altair as alternative graphing packages to matplotlib

## Visualization Theory

A clear graphic can convey the results of data science work quicker and more effectively than nearly any other approach. How to design and implement the optimal graphic for each scenario has been and is continuously studied today. Every element of visualizations from the color palette to the type of graph you choose and everything in between has an important impact on the ability of a graph to convey the point you want to make.

### Overview

In this lab you'll be introduced to two of the main frameworks for visualization used in Python. First, to the object oriented approach used by `Matplotlib` and later the Grammar of Graphics approach used by libraries like `plotnine` and `altair`. We'll also briefly look at `seaborn` which is a hybrid of the two frameworks.

### Matplotlib Paradigm
Matplotlib takes an object oriented approach that is akin to a painter. First you choose the size of your (virtual) canvas, then you choose what specific points, lines, and polygons to draw on the canvas, and finally you add finishing touches like titles, labels, legends, and styling. To simplify things for common graphs there are methods so you can simply ask for a bar chart to be made with the data you provide and all the bars will be drawn rather than you having to draw each one one by one. An advantage of Matplotlib is it gives you fine grained control if you did ever want to draw bars one by one though the downside of this is all data has to be preprocessed before being used for graphing.

Matplotlib is one of the most commonly used packages for creating visualizations with python in academia and will be the package we focus on in this lab.

### Grammar of Graphics Paradigm
By contrast, the Grammar of Graphics approach is more like ordering a painting from an artist. You tell it the data set to use, what type of graph you'd like, any particular coloring and scaling, and then the implementation of the grammar of graphics you're using such as `plotnine` or `altair` will take care of the rest. An advantage of the grammar of graphics is the clarity that is enforced by it's clear structure; however, you lose some of the fine grained control available in object oriented approaches like `Matplotlib`. This approach is based on the visualization theory developed by Leland Wilkerson and implemented popularly in R with ggplot2 by Hadley Wickham.

## Setup

This lab will use both `pandas` and `python`. For graphing we'll primarily use `matplotlib`. We'll also see some `seaborn`, `altair`, and `plotnine`
To explore these libraries we'll be using a cleaned version of the dataset obtained from the [Chicago Open Data Portal](https://data.cityofchicago.org/Parks-Recreation/Beach-Weather-Stations-Automated-Sensors/k7hf-8y75/about_data), which contains data generated by three beach weather stations in Chicago. Our version of the data only contains records from 2024. Run this cell to load the packages and DataFrame.

```{python packages, exercise=TRUE, exercise.eval = FALSE, message = FALSE}
# data manipulation
import numpy as np
import pandas as pd
# graphing
import matplotlib.pyplot as plt
import altair
import seaborn as sns
import plotnine as p9

# so we can see all columns
pd.options.display.max_columns = 10

# To download this file go to ADD A HOSTED VERSION OF THIS FILE LATER

beach = pd.read_csv("./data/beach_data.csv", index_col = 0)
beach.head()
```


```{python main-setup, exercise=TRUE, include=FALSE, message=FALSE, exercise.setup="packages"}
beach_year_avg = beach.drop(columns=['Month', 'Hour', 'Day of Year']).groupby("Station Name").mean().reset_index()
stations = beach_year_avg['Station Name']
wind_avg = beach_year_avg['Wind Speed']
max_wind = beach[beach['Maximum Wind Speed'] < 100]['Maximum Wind Speed'] 
# dealing with weird outliers
hourly_wind = beach[beach['Maximum Wind Speed'] < 100]['Wind Speed']

beach_day_max = beach[beach['Station Name'] == 'Oak Street'][['Day of Year', 'Air Temperature']].groupby('Day of Year').max().reset_index().sort_values('Day of Year')

day = beach_day_max['Day of Year']
daily_temp = beach_day_max['Air Temperature']

beach_day_max_foster = beach[beach['Station Name'] == 'Foster'][['Day of Year', 'Air Temperature']].groupby('Day of Year').max().reset_index().sort_values('Day of Year')

daily_temp_oak = beach_day_max['Air Temperature']
daily_temp_foster = beach_day_max_foster['Air Temperature]
```

## Graphing with Matplotlib

Below you will be walked through the key components of Matplotlib. As you explore it may be useful to check out [Matplotlib's quick start guide](https://matplotlib.org/stable/users/explain/quick_start.html) or other parts of it's documentation for more details.

### Choosing your canvas: Figures and Axes
In Matplotlib the **figure** is the core element which sets the overall size of our canvas and also keeps track of everything being added to the canvas. Our **axes** are how we specify where on our figure we want our visualization to happen.   

Below you'll see a quick example of setting up the figure and axes before making a scatterplot. Feel free to experiment with the figure and axes by changing the `width`, `height`, `left_start`, `bottom_start`, `width_start`, and `height_start` variables.

```{python figure, exercise = TRUE, message = FALSE, exercise.eval=FALSE, exercise.setup="packages"}
width = 12
height = 6
left_start, bottom_start, width_start, height_start = (0.5, 0.5, .5, 0.5)
# do not edit below here
fig = plt.figure(figsize=(width, height))
ax = fig.add_axes((left_start, bottom_start, width_start, height_start), frame_on=True)
ax.scatter([1,2,3], [1,2,3])
plt.show()
```
Often we'll just let Matplotlib use the default figure with an axes spanning the entire figure size. Here's an example of that below using `subplots`
```{python subplots, exercise = TRUE, message = FALSE,exercise.eval=FALSE, exercise.setup="packages"}
fig, ax = plt.subplots()
ax.scatter([1,2,3], [1,2,3])
plt.show()
```
Alternatively we can just create a plot without explicitly setting a figure or axes though Matplotlib will be making them in the background automatically!
```{python no-figure, exercise = TRUE, message = FALSE, exercise.eval=FALSE, exercise.setup="packages"}
plt.scatter([1,2,3], [1,2,3]) 
# note how we have to do plt not ax.scatter
# this is because the axes hasn't been created when we call .scatter
plt.show()
```
Throughout the rest of this notebook we'll let Matplotlib handle making the figures and axes by default but knowing they exist and how to manipulate them can be useful as you explore more complicated graphing techniques. Checkout this [part of the documentation](https://matplotlib.org/stable/users/explain/axes/index.html) if you want to learn more about figures and axes!


### Common Graphs

As Data Scientists it is important we choose the right graph for the right data. As you practice making the different graphs below make sure to keep track of which graphs are best with which types of data.

#### Bar Chart
A Bar Chart is useful for displaying summaries or distributions of categorical information. It often has the individual categories on the x-axis with the height on the y-axis of each bar indicating the summary information for each category. In Matplotlib the simplest way to make a bar chart is by using `plt.bar` and providing a collection of labels as the first argument (`x`) and a collection of summary information as the second argument (`height`). Here is an example to see how it works looking at a made up grade distribution.

```{python basic-bar, exercise = TRUE, message = FALSE, exercise.eval=FALSE, exercise.setup="packages"}
grade_categories = ["A", "B", "C", "D","F"]
students_per_category = [14, 10, 5, 2, 1]
plt.bar(x=grade_categories, height=students_per_category)
```

1. We have stored the names of the Beach Weather stations in `stations` and their average wind reading for 2024 in `wind_avg`. Make a bar chart displaying the average wind recorded at each weather station in 2024.
```{python beach-avg-setup, include=FALSE, exercise = FALSE, message = FALSE, exercise.setup="packages"}
beach_year_avg = beach.drop(columns=['Month', 'Hour', 'Day of Year']).groupby("Station Name").mean().reset_index()
stations = beach_year_avg['Station Name']
wind_avg = beach_year_avg['Wind Speed']
```
```{python beach-avg-wind-bar, include=TRUE, exercise = TRUE, message = FALSE, exercise.setup="beach-avg-setup"}

```
```{python beach-avg-wind-bar-solution, message = FALSE, warning = FALSE, echo = FALSE}
plt.bar(stations, wind_avg)
```

```{r beach-avg-wind-bar-code-check, message = FALSE, warning = FALSE}
grade_this_code(
  correct = "Great Bars",
)
```

Bar Charts can help us quickly compare between different categories. Checkout the [Matplotlib Bar Chart Documentation](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.bar.html) to see more ways to customize your bar charts.

#### Histogram
Histograms are useful when we want to look at the distribution of 1-dimensional numerical data. By breaking numbers into bins then plotting the count or percentage of data in each bin they make it easy to see an entire distribution at a glance. In Matplotlib the simplest way to make a histogram is with `plt.hist(x, bins, density)` where x is the data to be plotted, bins is the number of bins or a list with the start and stop points for all the bins, and density is False for counts and True to see densities. Play around with the bins and density arguments below to see how they effect the histogram. 

```{python basic-hist, exercise = TRUE, message = FALSE, exercise.eval=FALSE, exercise.setup="packages"}
np.random.seed(42) # for consistent samples
numbers = np.random.choice(np.arange(100), size=50) # a random sample of numbers
plt.hist(x=numbers, bins=10, density=False) # making the graph
```

```{r bins-impact, echo=FALSE}
question("2. As you increase the number of bins what is the impact on the histogram? CHECK ALL THAT APPLY",
         answer("Nothing happens"),
         answer("The bins are wider"),
         answer("The bins are narrower", correct=TRUE),
         answer("There is less blank space"),
         answer("There is more blank space", correct=TRUE), 
        allow_retry = TRUE,
  random_answer_order = TRUE)
```
3. Make your own count histogram with 10 bins using the hourly maximum wind readings which have been stored for you in the variable `max_wind`.
```{python beach-hist-setup, include=FALSE, exercise = FALSE, message = FALSE, exercise.setup="packages"}
max_wind = beach[beach['Maximum Wind Speed'] < 100]['Maximum Wind Speed'] # dealing with weird outliers
hourly_wind = beach[beach['Maximum Wind Speed'] < 100]['Wind Speed']

```
```{python beach-max-wind-hist, include=TRUE, exercise = TRUE, message = FALSE, exercise.setup="beach-hist-setup"}

```
```{python beach-max-wind-hist-solution, message = FALSE, warning = FALSE, echo = FALSE}
plt.hist(max_wind, bins=10)
```

```{r beach-max-wind-hist-code-check, message = FALSE, warning = FALSE}
grade_this_code(
  correct = "Histogram :)"
)
```

As you've seen histograms are a powerful tool to quickly summarize 1-D numerical data. Checkout the [Matplotlib histogram documentation](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.hist.html) to see more ways to fine tune your histograms.

#### Scatterplot
So far we have looked at single dimensional data. However, sometimes we may want to look at the relationship between two dimensions (variables) of our data. A Scatterplot is useful for quickly seeing that relationship. A Scatterplot is made up of points where each point (x,y) is the x value and y value for a particular record in our dataset. In Matplotlib the simplest way to make a scatterplot is by using `plt.scatter(x,y)` and providing a collection of data as the first argument (`x`) and a collection of different data for the same records in the same order as the second argument (`y`). Here is an example to see how it works looking at two randomly generated samples.

```{python basic-scatter, exercise = TRUE, message = FALSE, exercise.eval=FALSE, exercise.setup="packages"}
np.random.seed(42) # for consistency
# generating random samples
x = np.random.choice(np.arange(100), size=200)
y = np.random.choice(np.arange(100), size=200)
# drawing the scatterplot
plt.scatter(x=x, y=y)
```

4. We have stored the hourly wind speeds in `hourly_wind` and the maximum for each hour in `max_wind`. Make a scatterplot chart displaying the relationship between the hourly and maximum wind recorded at the weather stations in 2024. Let the x-axis contain the hourly wind readings.
```{python beach-wind-scatter, include=TRUE, exercise = TRUE, message = FALSE, exercise.setup="beach-hist-setup"}

```

```{python beach-wind-scatter-solution, message = FALSE, warning = FALSE, echo = FALSE}
plt.scatter(hourly_wind, max_wind)
```

```{r beach-wind-scatter-code-check, message = FALSE, warning = FALSE}
grade_this_code(
  correct = "Great Points!",
)
```

Scatterplots can help us quickly identify relationships (or the lack thereof) between different variables in a dataset. They are also a useful tool for exploratory data analysis as we can see above with the plot revealing a point which was erroneously collected. Checkout the [Matplotlib Scatterplot Documentation](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.scatter.html) to see more ways to customize your scatterplots (i.e. coloring, resizing, or changing the shape of your points).

#### Line Chart
Line charts are also used when we want to look at the relationship between two dimensions (variables) of our data. However, unlike a Scatterplot lineplots always have the x-axis convey some measure of sequential data and therefore a line plot is useful for quickly seeing relationships over time. A Scatterplot is made up of points connected by lines to their closest neighboring point where each point (x,y) is the (temporal) x value and y value for a particular record in our dataset. In Matplotlib the simplest way to make a line plot is by using `plt.plot(x,y)` and providing a collection of data as the first argument and a collection of different data for the same records in the same order as the second argument. Note you can also plot single points this way by making x and y both single numbers. Here is an example to see how it works looking at a graph of the sine function.

```{python basic-line, exercise = TRUE, message = FALSE, exercise.eval=FALSE, exercise.setup="packages"}
x = np.arange(-4, 4, 0.2)
y = np.sin(x)
# drawing the line plot
plt.plot(x, y)
```


5. We have stored the daily temperature high readings for the Oak Street beach in `daily_temp` and the day of the year in `day`. Make a line chart displaying the daily temperature high readings at that beach throughout 2024.
```{python beach-temp-line-setup, include=FALSE, exercise = FALSE, message = FALSE, exercise.setup="packages"}
beach_day_max = beach[beach['Station Name'] == 'Oak Street'][['Day of Year', 'Air Temperature']].groupby('Day of Year').max().reset_index().sort_values('Day of Year')

day = beach_day_max['Day of Year']
daily_temp = beach_day_max['Air Temperature']
```

```{python beach-temp-line, include=TRUE, exercise = TRUE, message = FALSE, exercise.setup="beach-temp-line-setup"}

```

```{python beach-temp-line-solution, message = FALSE, warning = FALSE, echo = FALSE}
plt.plot(day, daily_temp)
```

```{r beach-temp-line-code-check, message = FALSE, warning = FALSE}
grade_this_code(
  correct = "Great Points!",
)
```

Line Plots can help us quickly identify temporal relationships (or the lack thereof) between different variables in a dataset. Checkout the [Matplotlib Line Plot Documentation](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html) to see more ways to customize your line plots (i.e. coloring, resizing, or changing the style of your lines).


### Finishing Touches: Labels, Legends, and Tick marks
So far we have focused on simply making the graphs; however, no visualization is complete without an informative title and labels. At times it can also be useful to customize your tick marks, add a legend or other changes around the graph itself to ensure the graphs conveys the right message.

There are too many different ways to customize graphs in Matplotlib to show here but below you'll practice how to add axis labels, a title, and a legend as well as how to modify tick marks. To see more customization options check out [this section of the quickstart guide](https://matplotlib.org/stable/users/explain/quick_start.html#styling-artists)

After we've made a figure or one has been generated automatically through making a graph we can add an x-axis label with `plt.xlabel('text')`, a y-axis label with `plt.ylabel('text')`. To add a title we can do `plt.title('text')`.

6. Add the title `Average Wind by Beach in 2024`, and the y-axis label as `Avg Wind` and the x-axis label as `Beach Name` to the bar chart we made earlier.

```{python beach-avg-wind-bar-labeled, include=TRUE, exercise = TRUE, message = FALSE, exercise.setup="main-setup"}
...
...
...
...
```

```{python beach-avg-wind-bar-labeled-solution, message = FALSE, warning = FALSE, echo = FALSE}
plt.bar(stations, wind_avg)
plt.xlabel("Beach Name")
plt.ylabel("Avg Wind")
plt.title("Average Wind by Beach in 2024")
```

```{r beach-avg-wind-bar-labeled-code-check, message = FALSE, warning = FALSE}
grade_this_code(
  correct = "Great Bars",
)
```

Sometimes when we have more encodings on a single plot it can be useful to include a legend to explain what is what. To do so we often have to add a label argument to each individual plot.

7. Edit the code below so that the first line plot receives the label of 'Oak Street Beach' and the second of 'Foster Beach' in a new legend located in the lower center of the graph. If you're stuck check out the [Legend documentation](https://matplotlib.org/stable/api/_as_gen/matplotlib.axes.Axes.legend.html).

```{python beach-line-overlaid-setup, include=FALSE, exercise = FALSE, message = FALSE, exercise.setup="beach-temp-line-setup"}
beach_day_max_foster = beach[beach['Station Name'] == 'Foster'][['Day of Year', 'Air Temperature']].groupby('Day of Year').max().reset_index().sort_values('Day of Year')

day = beach_day_max['Day of Year']
daily_temp_oak = beach_day_max['Air Temperature']
daily_temp_foster = beach_day_max_foster['Air Temperature']
```

```{python beach-temp-overlaid-line, include=TRUE, exercise = TRUE, message = FALSE, exercise.setup="beach-line-overlaid-setup"}
plt.plot(day, daily_temp_oak, label=...)
plt.plot(day, daily_temp_foster, label=...)
...
```
```{python beach-temp-overlaid-line-solution, message = FALSE, warning = FALSE, echo = FALSE}
plt.plot(day, daily_temp, label="Oak Street")
plt.plot(day, daily_temp_foster, label="Foster")
plt.legend(loc='lower center')
```
```{r beach-temp-overlaid-line-code-check, message = TRUE, warning = FALSE}
grade_this_code(
  correct = "What an absolute legend!",
)
```



## Building on Matplotlib: Pandas and Seaborn

Because making visualizations is such a key part of the data science workflow `pandas` has methods for data frames that call the `matplotlib` package behind the scene simplifying the graphing process. Since the `pandas` graphing methods are built on top of `matplotlib` all the customization you just saw earlier still works. 

All of the graphs we've discussed can be made from a data frame using `df.plot.graph_name(**args)`. If you're not sure how to implement a particular graph check out the **Plotting** section of the [pandas cheatsheet](https://pandas.pydata.org/Pandas_Cheat_Sheet.pdf) or the [pandas plotting documentation](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.plot.html). Below you'll recreate some of the graphs from earlier to see how we can harness the power of combining pandas and matplotlib.

#TODO
Repeat questions 1-7 and add maybe another. Explain how they'll have to manipulate a df prior to calling .plot sometimes.
Still need to add a scatterplot and the overlaid line chart. Then add seaborn. After add grammar of graphics

Before you start on the remaining exercises here is an example to see how `pandas` implements a basic bar chart differently than `matplotlib`. Note the need to create a series or DataFrame first.

```{python pandas-basic-bar, exercise = TRUE, message = FALSE, exercise.eval=FALSE, exercise.setup="packages"}
grade_categories = ["A", "B", "C", "D","F"]
students_per_category = [14, 10, 5, 2, 1]
grades = pd.DataFrame({"Grades" : grade_categories, "# Students" : students_per_category})
grades.plot.bar("Grades", '# Students')
```

As you can see for data that is already stored in a list it may be easier to just use `matplotlib` directly. However, using pandas also automatically added a x-axis label, a legend label, and allowed us to just reference columns from a dataframe directly making for a much smoother process when our data is already in a dataframe. 

8. Recreate the bar chart displaying the average wind recorded at each weather station in 2024 using the dataframe created for you below. Make sure it has the same labels as question 6. As a challenge do it all in one line with the xaxis tick marks rotated to 0 degrees for clearer visibility.


```{python beach-avg-pandas-setup, include=TRUE, exercise = TRUE, message = FALSE, exercise.setup="packages"}
beach_year_avg = beach.drop(columns=['Month', 'Hour', 'Day of Year']).groupby("Station Name").mean().reset_index()
```
```{python beach-avg-wind-bar-pandas, include=TRUE, exercise = TRUE, message = FALSE, exercise.setup="beach-avg-pandas-setup"}
...
...
...
...
```
```{python beach-avg-wind-bar-pandas-solution, message = FALSE,warning = FALSE, echo = FALSE}
beach_year_avg.plot.bar("Station Name", "Wind Speed", xlabel="Beach Name", ylabel="Avg Wind", title="Average Wind by Beach in 2024", rot=0)
```

```{python beach-avg-wind-bar-pandas-hint-1, message = FALSE,warning = FALSE, echo = FALSE}
checkout the df.plot documentation to see how we can supply the axis labels and title directly
```

```{python beach-avg-wind-bar-pandas-hint-2, message = FALSE,warning = FALSE, echo = FALSE}
checkout the rot argument of df.plot.bar for help rotating the xticks labels
```

```{r beach-avg-wind-bar-pandas-code-check, message = FALSE, warning = FALSE}
grade_this_code(
  correct = "Great Bars",
)
```

Notice how while we still needed to manipulate the dataframe prior to graphing. Once our dataframe was ready we didn't need to extract the data as series like previously and could plot directly.

Let's keep practicing this time with histograms. 

9. Reproduce the histogram from question 3 with the updated title and labels. This time change the color to `"green"`.

```{python beach-max-wind-hist-pandas-setup, include=TRUE, exercise = TRUE, message = FALSE, exercise.setup="packages"}
no_outlier_wind = beach[beach['Maximum Wind Speed'] < 100][['Maximum Wind Speed']] # dealing with weird outliers
```
```{python beach-max-wind-hist-pandas, include=TRUE, exercise = TRUE, message = FALSE, exercise.setup="beach-max-wind-hist-pandas-setup"}
...
plt.title("Distribution of Max Winds")
plt.xlabel("Max Wind in MPH")
plt.ylabel("Count")
```
```{python beach-max-wind-hist-pandas-solution, message = FALSE, warning = FALSE, echo = FALSE}
no_outlier_wind.plot.hist(color="green", bins=10)
plt.title("Distribution of Max Winds")
plt.xlabel("Max Wind in MPH")
plt.ylabel("Count")
```

```{r beach-max-wind-hist-pandas-code-check, message = FALSE, warning = FALSE}
grade_this_code(
  correct = "Histogram :)"
)
```

Notice how we didn't even have to pass any data to `.hist`! As long as your data is univariate calling df.hist will be enough because by default the plotting methods within pandas attempt to plot every variable in the dataframe where possible. Let's put this to our advantage to make a overlaid histogram.

10. Make an overlaid histogram of both the maximum and hourly wind distributions. Let `Matplotlib` generate the colors automatically and use 10 bins.


```{python beach-overlaid-wind-hist-pandas-setup, include=TRUE, exercise = TRUE, message = FALSE, exercise.setup="packages"}
no_outlier_wind = beach[beach['Maximum Wind Speed'] < 100][['Wind Speed', 'Maximum Wind Speed']] # dealing with weird outliers
```
```{python beach-overlaid-wind-hist-pandas, include=TRUE, exercise = TRUE, message = FALSE, exercise.setup="beach-overlaid-wind-hist-pandas-setup"}
...
plt.title("Distribution of Max Winds")
plt.xlabel("Max Wind in MPH")
plt.ylabel("Count")
```
```{python beach-overlaid-wind-hist-pandas-solution, message = FALSE, warning = FALSE, echo = FALSE}
no_outlier_wind.plot.hist(bins=10)
plt.title("Distribution of Max Winds")
plt.xlabel("Max Wind in MPH")
plt.ylabel("Count")
```

```{r beach-overlaid-wind-hist-pandas-code-check, message = FALSE, warning = FALSE}
grade_this_code(
  correct = "Histogram :)"
)
```

While it's easy to overlay histograms and bar charts in `pandas` it can be more challenging to do so with line plots. That's where packages like `seaborn` which further build on `matplotlib` and `pandas` can be helpful. Check out the [seaborn documentation](https://seaborn.pydata.org/generated/seaborn.lineplot.html)

11. Recreate the overlaid line plot from question 7 using seaborn. Let the legend go where ever seaborn thinks is best.

```{python beach-line-overlaid-seaborn-setup, include=TRUE, exercise = TRUE, message = FALSE, exercise.setup="packages"}
beach_day_max = beach[beach['Station Name'] != '63rd Street'][['Day of Year', 'Air Temperature', 'Station Name']].groupby(['Day of Year', 'Station Name']).max().reset_index().sort_values('Day of Year')
```

```{python beach-line-overlaid-seaborn, include=TRUE, exercise = TRUE, message = FALSE, exercise.setup="beach-line-overlaid-seaborn-setup"}

```
```{python beach-line-overlaid-seaborn-solution, message = FALSE, warning = FALSE, echo = FALSE}
sns.lineplot(beach_day_max, x="Day of Year", y="Air Temperature", hue="Station Name")
```
```{r beach-line-overlaid-seaborn-code-check, message = TRUE, warning = FALSE}
grade_this_code(
  correct = "Great job with Seaborn!",
)
```



## Grammar of Graphics Approach

1. Find the dimensions of the `epicurious` dataset. How many observations are there? How many variables are there?

```{python size, exercise = TRUE, message = FALSE, exercise.setup="packages"}

```

```{python size-solution, message = FALSE, warning = FALSE, echo = FALSE}
epicurious.shape
```

```{r size-code-check, message = FALSE, warning = FALSE}
grade_this_code(
  correct = "Secret word",
)
```

2. View the head of the dataset. What kinds of variables do you see?

```{python head, exercise = TRUE, message = FALSE, exercise.setup="packages"}

```


```{python head-solution, message = FALSE, warning = FALSE, echo = FALSE}
epicurious.head()
```


```{r head-code-check, message = FALSE, warning = FALSE}
grade_this_code(
  correct = "Secret word",
)
```

3. Remember from Data 118 that a variable can have numbers as data but not be numeric (eg 0, 1 to mean no, yes). We call these variables "binary". Since many of the variables are binary variables indicating different facts about the recipes, let's discard most of them for now and focus on the numeric variables. Identify which of the variables are numeric (if you get stuck, check out the [data dictionary](https://www.kaggle.com/datasets/hugodarwood/epirecipes)).  Save a version of the dataset with only those variables as `epicurious_num`. 

```{python filter, exercise = TRUE, message = FALSE, exercise.setup="packages"}

```

```{python filter-solution, message = FALSE, warning = FALSE, echo = FALSE}
epicurious_num = epicurious[['rating', 'calories', 'protein', 'fat', 'sodium']]
```

```{r filter-code-check, message = FALSE, warning = FALSE}
grade_this({
  if (identical(epicurious_num, epicurious[['rating', 'calories', 'protein', 'fat', 'sodium']])) {
    pass("Secrets")
  }
  fail()
})
```

4. Compute a table of summary statistics for these variables, including the minimum, first quartile, median, third quartile, maximum, mean, and standard deviation. Look at these numbers, and think about any red flags you see (we will come back to this).

```{python describe-setup}
import numpy as np
import pandas as pd

epicurious = pd.read_csv("./www/epi_mini.csv")
epicurious_num = epicurious[['title', 'rating', 'calories', 'protein', 'fat', 'sodium']]
```

```{python describe, exercise = TRUE, message = FALSE, exercise.setup="describe-setup"}

```

```{python describe-solution, message = FALSE, warning = FALSE, echo = FALSE}
epicurious_num.describe()
```

```{r describe-code-check, message = FALSE, warning = FALSE}
grade_this_code(
  correct = "stuff"
)
```

5. It is also helpful to discuss how many missing values the dataset has. Identify the percentage of missing values in the `protein` column.

```{python missing, exercise = TRUE, message = FALSE, exercise.eval = FALSE, exercise.setup="describe-setup"}

```

```{python missing-solution, message = FALSE, warning = FALSE, echo = FALSE, eval = FALSE}
sum(epicurious_num['protein'].isna())/len(epicurious_num['protein'])
```

```{r missingquestion, echo=FALSE}
question_numeric(text = "What percent of `protein` is missing? (Round to 1 decimal place.)",
         answer("18.5", correct = TRUE),
         allow_retry = TRUE,
         min = 0, 
         max = 100,
         step = 0.1,
         post_message = "Congratulations! You have found the first secret word: AGREEMENT.")
```


```{r approp, echo=FALSE}
question("6. Is it appropriate to drop the missing data?",
  answer("Yes", message = "A general rule of thumb is that if the observations are missing at random (i.e., the reason that they are missing is not tied to any other confounding variable) and less than 10% of the values are missing, you can simply discard the values. From the last question we learned that about **20%** of the values for `calories`, `protein`, `sodium`, and `fat` are missing."),
  answer("No", correct = TRUE),
  allow_retry = TRUE,
  random_answer_order = FALSE,
  post_message = "Congratulations! You have found the second secret word: SAY.")
```

A general rule of thumb is that if the observations are missing at random (i.e., the reason that they are missing is not tied to any other confounding variable) and less than 10% of the values are missing, you can simply discard the values. From the last question we learned that about **20%** of the values for `protein` are missing (the other variables are similar)--however, we won't learn tools for dealing with missing values until later. So, even though it's not the best idea, we are going to drop the rows with missing values.

7. Drop the rows with missing values and save the remaining values in a new data frame called `epicurious_num_nd`.

```{python drop, exercise = TRUE, message = FALSE, exercise.setup="describe-setup"}

```

```{python drop-solution, message = FALSE, warning = FALSE, echo = FALSE}
epicurious_num_nd = epicurious_num.dropna()
```

```{r drop-code-check, message = TRUE, warning = FALSE}
# grade_this_code(
#   correct = "Things and stuff",
#   incorrect = "Stuff and things"
# )
grade_this({
  if(identical(.result, .solution)){
    print(.result)
    pass("made it")
  }
  else{
    fail("didn't make it")
  }
})

```

## Making Plots

In DATA 11800 you likely used `matplotlib` and/or `seaborn` to create visualizations. There are many different python packages out there to create interesting data visuals. The package we are going to explore in this lab is `plotnine`. Run the following code chunk.

```{python packages2, exercise=TRUE, exercise.eval = FALSE, message = FALSE, exercise.setup="describe-setup"}
import plotnine as p9
```

```{python plot-setup, echo = FALSE, exercise.eval = FALSE, message = FALSE}
import numpy as np
import pandas as pd
import plotnine as p9

epicurious = pd.read_csv("http://raw.githubusercontent.com/nussisthebaum/DATA119-Labs/refs/heads/main/data/epi_mini.csv")
epicurious_num = epicurious[['title', 'rating', 'calories', 'protein', 'fat', 'sodium']]
epicurious_num_nd = epicurious_num.dropna()
```


`plotnine` is based off `ggplot2` from R and has a similar aesthetic. Here is the basic idea: You, as the user, tell `plotnine` what data to use, how to map the variables to the different aesthetics (encoding channels) of the graph, and what type of graph you need-- `plotnine` takes care of the rest!

### Histograms

First, we start by providing the data and mapping the variables to the graph's aesthetics. This means that we are defining things like what's on the $x$-axis or what color the graph is, among many others.

Below is a sample line of code for investigating the average ratings of the different recipes. Note that the functions `ggplot()` and `aes()` come from `plotnine`-- the data frame comes first, then the aesthetics of the graph are defined with `aes()`. You can view [plotnine syntax here](https://plotnine.readthedocs.io/en/stable/).

```{python badplot, exercise=TRUE, exercise.eval = FALSE, message = FALSE, exercise.setup="plot-setup"}
(p9.ggplot(epicurious_num_nd, p9.aes(x = 'rating')))
```

If you run this chunk, a big, nearly blank box appears--there is no actual graph, but we can see that the `rating` variable is now located on the $x$-axis .There's nothing there because we haven't added a `geom` yet. A `geom` is a command representing the type of plot we want. To add a histogram, we use + `geom_histogram()` from `plotnine.`

```{python hist, exercise=TRUE, exercise.eval = FALSE, message = FALSE, exercise.setup="plot-setup"}
(p9.ggplot(epicurious_num_nd, p9.aes(x = 'rating')) 
 + p9.geom_histogram())
```

8. Do you see a warning message saying `"Pick better value with 'binwidth'"`? This error is unique to `geom_histogram()`. To fix the warning, you can change the number of bins by adding a new argument, `bins = 10`, into the `geom_histogram()` function.

```{python bins, exercise=TRUE, message = FALSE, exercise.setup="plot-setup"}
(p9.ggplot(epicurious_num_nd, p9.aes(x = 'rating')) 
+ p9.geom_histogram(bins = ___))
```

```{python bins-solution, message = FALSE, warning = FALSE, echo = FALSE}
(p9.ggplot(epicurious_num_nd, p9.aes(x = 'rating')) 
+ p9.geom_histogram(bins = 10))
```

```{r bins-code-check, message = FALSE, warning = FALSE}
grade_this_code(
  correct = "stuffnthings",
  incorrect = "thingsnstuff"
)
```

```{r impact, echo=FALSE}
question("9. What happens to the histogram? Are there any differences? CHECK ALL THAT APPLY",
         answer("Nothing Happens"),
         answer("The bins are wider", correct=TRUE),
         answer("The bins are narrower"),
         answer("The trend changes"),
         answer("The trend stays the same", correct=TRUE),
         answer("There is less blank space", correct=TRUE), 
        allow_retry = TRUE,
  random_answer_order = TRUE,
  post_message = "Congratulations! You have found the third secret word: HALF.")

```

You can also avoid the message by specifying the `binwidth` instead of `bins`. There is a direct relationship between the bin width and the number of bins, so setting one also fixes the other. In general, increasing the number of bins leads to narrower wins, and decreasing the number of bins leads to wider bins.

10. Instead of creating a histogram with 10 bins, create a histogram where the bin width is 0.5.

```{python binwidth, exercise=TRUE, message = FALSE, exercise.setup="plot-setup"}
(p9.ggplot(epicurious_num_nd, p9.aes(x = 'rating')) 
+ p9.geom_histogram(binwidth = ___))
```

```{python binwidth-solution, message = FALSE, warning = FALSE, echo = FALSE}
(p9.ggplot(epicurious_num_nd, p9.aes(x = 'rating')) 
+ p9.geom_histogram(binwidth = 0.5))
```

```{r binwidth-code-check, message = FALSE, warning = FALSE}
grade_this_code(
  correct = "yep",
  incorrect = "Nope"
)
```

Notice that on the $y$-axis we are displaying the counts of the observations in each bin. We can change this to instead display the proportion by adding another argument to `ggplot()`.

```{python proportion, exercise=TRUE, exercise.eval = FALSE, message = FALSE, exercise.setup="plot-setup"}
(p9.ggplot(epicurious_num_nd, p9.aes(x = 'rating', y=p9.after_stat('density'))) 
 + p9.geom_histogram(binwidth = 0.5))
```

11. Look at the `plotnine` syntax and add a command that will add a smooth density estimate to the plot.

```{python density, exercise=TRUE, message = FALSE, exercise.setup="plot-setup"}
(p9.ggplot(epicurious_num_nd, p9.aes(x = 'rating', y=p9.after_stat('density'))) 
 + p9.geom_histogram(binwidth = 0.5) 
 + ___ )
```

```{python density-solution, message = FALSE, warning = FALSE, echo = FALSE}
(p9.ggplot(epicurious_num_nd, p9.aes(x = 'rating')) +
  p9.geom_histogram(binwidth = 0.5) +
  p9.geom_density())
```

```{r density-code-check, message = FALSE, warning = FALSE}
grade_this_code(
  correct = "yep",
  incorrect = "Nope"
)
```

12. Now, let's look at `calories` instead of `rating`.

```{python calorie, exercise=TRUE, message = FALSE, exercise.setup="plot-setup"}
(p9.ggplot(epicurious_num_nd, p9.aes(x = ___ , y=p9.after_stat('density'))) 
 + p9.geom_histogram(bins = 30) 
 + p9.geom_density())
```

```{python calorie-solution, message=FALSE, warning = FALSE, echo = FALSE}
(p9.ggplot(epicurious_num_nd, p9.aes(x = 'calories', y=p9.after_stat('density'))) 
 + p9.geom_histogram(bins = 30) 
 + p9.geom_density())
```

```{r calorie-code-check, message=FALSE, warning=FALSE}
grade_this_code(
  correct = "words of praise",
  incorrect = "words of encouragement}"
)
```


13. We can also see in the `calories` plot that the distributions are skewed by a handful of extreme values (which we also saw earlier. Find the top ten largest values for `calories`, `protein`, `fat`, and `sodium` (Hint: some of the top ten might be repeated for different variables). Which recipes do they correspond to? Create a DataFrame that will help you solve the next question

```{python skew, exercise=TRUE, exercise.eval = FALSE, message = FALSE, exercise.setup="plot-setup"}

```

```{python skew-hint-1}
# we can use .nlargest along with index to get the relevant indices
# here is an example for top 10 recipes by calories
maxcal = epicurious_num_nd['calories'].nlargest(n=10).index
# now you need to figure out how to get those that are in the top 10 for each
```

```{python skew-hint-2}
# given two sets of numbers l1 and l2 we can use set.union(l1, l2) to get all numbers in either l1 or l2
# how can we use this to get every recipe in the top 10 across all the categories
# run the following code to see how it works
l1 = [1, 2, 3]
l2 = [2, 4, 6]
set.union(l1, l2)
```

```{python skew-hint-3}
maxcal = epicurious_num_nd['calories'].nlargest(n=10).index
maxpro = epicurious_num_nd['protein'].nlargest(n=10).index
maxfat = epicurious_num_nd['fat'].nlargest(n=10).index
maxsod = epicurious_num_nd['sodium'].nlargest(n=10).index

maxvals = set().union(maxcal, maxpro, maxfat, maxsod)

epicurious_num_nd.loc[list(maxvals),]
```

```{r skewq, echo=FALSE}
question("Select all true statements using the DataFrame you just created.",
         answer("Pear-Cranberry Mincemeat Lattice Pie has the most calories", correct = TRUE),
         answer("Whole Branzino Roasted in Salt is included because of it's high fat content", message="Is Whole Branzino's fat content in the top 10?"),
         answer("Grilled Lamb Chops with Porcini Mustard is a duplicate entry", correct = TRUE),
         answer("There are 10 recipes in this dataframe", message="There should be 14"),
         answer("Of the rows in this dataframe, 6 have a rating of 5.0", correct=TRUE), 
         allow_retry = TRUE,
         random_answer_order = TRUE,
         post_message = "Congratulations! You have found the fourth secret word: SUITCASE.")
```


This cell will remove the rows containing those values, drop duplicate values, and save the remaining values in a new DataFrame called `epicurious_num_clean`. 

```{python clean, exercise=TRUE, exercise.eval=FALSE, message=FALSE, exercise.setup="plot-setup"}
maxcal = epicurious_num_nd['calories'].nlargest(n=10).index
maxpro = epicurious_num_nd['protein'].nlargest(n=10).index
maxfat = epicurious_num_nd['fat'].nlargest(n=10).index
maxsod = epicurious_num_nd['sodium'].nlargest(n=10).index

maxvals = set().union(maxcal, maxpro, maxfat, maxsod)

epicurious_num_clean = epicurious_num_nd.drop(labels = maxvals, axis=0).drop_duplicates()
```

14. Adjust the code used to create the `calories` graph to use the new filtered data.

```{python calorieclean, exercise=TRUE, message = FALSE, exercise.setup="clean"}
(p9.ggplot(___, p9.aes(x = 'calories', y=p9.after_stat('density'))) 
 + p9.geom_histogram(bins = 30) 
 + p9.geom_density())
```

```{python calorieclean-solution, message=FALSE, warning = FALSE, echo = FALSE}
(p9.ggplot(epicurious_num_clean, p9.aes(x = 'calories', y=p9.after_stat('density'))) 
 + p9.geom_histogram(bins = 30) 
 + p9.geom_density())
```

```{r calorieclean-code-check, message=FALSE, warning=FALSE}
grade_this_code(
  correct = "things",
  incorrect = "stuff"
)
```


### Scatterplots

15. Let's continue to the last type of graph we will review for this lab, the scatterplot. Use the `plotnine` syntax once again to look up the appropriate `geom` you need. Create a plot displaying the relationship between `calories` and `fat`. Notice that unlike the other plots we have created, such as histograms and densities, you have to supply an $x$ and a $y$ aesthetic. Remember that $x$ is traditionally the explanatory variable and $y$ is traditionally the response--which one makes sense to use as the explanatory variable here?

```{python scatter, exercise=TRUE, message = FALSE, exercise.setup="clean"}
(p9.ggplot(epicurious_num_clean, p9.aes(x = '____' , y = '___' )) 
 + ___)

```

```{python scatter-solution, message=FALSE, warning = FALSE, echo = FALSE}
(p9.ggplot(epicurious_num_clean, p9.aes(x = 'fat', y = 'calories')) 
 + p9.geom_point())

```

```{r scatter-code-check, message=FALSE, warning=FALSE}
grade_this_code(
  correct = "stuff",
  incorrect = "things"
)
```

```{r scatterq, echo=FALSE}
question("16. Select all true statements about the association pictured in the graph above.",
         answer("Positive", correct=TRUE),
         answer("Negative"),
         answer("Linear", correct=TRUE),
         answer("Non-linear"),
         answer("Weak"),
         answer("Strong", correct=TRUE), 
         allow_retry = TRUE,
  random_answer_order = TRUE,
  post_message = "Congratulations! You have found the fifth and final secret word: QUARTER.")
```

17. You can change the color of the point by adding a `color` argument to `geom_point()`. Try adding your favorite color to the cell below.

```{python scattercolor, exercise=TRUE, exercise.eval=FALSE, message=FALSE, exercise.setup="clean"}
(p9.ggplot(epicurious_num_clean, p9.aes(x = 'fat', y = 'calories')) 
 + p9.geom_point(color = ___))
```

In addition to coloring the points a single color, color can also be used to encode data. The following chunk is an example of how to color the points by `rating`.

```{python colorcode, exercise=TRUE, exercise.eval=FALSE, message=FALSE, exercise.setup="clean"}
(p9.ggplot(epicurious_num_clean, p9.aes(x = 'fat', y = 'calories', color = 'rating')) 
 + p9.geom_point())
```


18. Using the tools you've learned in this lab, create a plot of two or three variables that you find interesting. This is not checked and has no correct answer, use your imagination.

```{python free, exercise=TRUE, exercise.eval=FALSE, message=FALSE, exercise.setup="clean"}

```

