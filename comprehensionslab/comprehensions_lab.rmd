---
title: "Advanced Iteration"
output: 
   learnr::tutorial:
      css: css/custom-styles.css
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(error = TRUE)
knitr::knit_engines$set(python = reticulate::eng_python)

library(shiny)
library(gradethis)
library(learnr)
library(reticulate)


gradethis_setup()
tutorial_options(exercise.completion = FALSE, "\\.{3}")
```

```{r header, echo = FALSE}
library(htmltools)

tags$div(
  class = "topContainer",
  tags$div(
    class = "logoAndTitle",
    tags$img(
      src = "./images/dsi_logo.png",
      alt = "DSI Logo",
      class = "topLogo"
    ),
    tags$h1("Advanced Iteration", class = "pageTitle")
  )
)
```

## Goals

The goals of this lab to are learn and gain experience using advanced iteration techniques. 

* Students will be able to read and write list comprehensions
* Students will be able to read and write dictionary comprehensions
* Students will be able to know how and when to use `zip` and `enumerate`
  
### Advanced Iteration Techniques
So far you have learned about for and while loops. In this lab we will introduce **comprehensions**. Comprehensions allow us to succinctly create new lists, sets, and dictionaries all in one line. They are generally faster than the equivalent for loop as well; however, they can be harder to read. As a data scientist it will be your responsibility to decide between using a standard for loop or a comprehension as you trade off between readability and speed/conciseness. In learning you about these techniques we'll introduce to you the `enumerate` and `zip` functions which can make it easier to keep track of an index when iterating or to iterate through multiple iterable objects at once.

## Setup

For this lab we will be using the `pandas`, and `numpy` modules in Python, as well as a new dataset: `classroom_locations`. The classroom locations dataset is based on the [university directory](https://registrar.uchicago.edu/faculty-staff/classroom-scheduling/buildings-directory-2/) and also includes geocodes which were added on.

```{python setup_py, context="setup", echo = FALSE}
import numpy as np
import pandas as pd
import math

uni_directory = pd.read_csv("data/university_directory.csv").iloc[:, 0:4]


def local_distance_mi(lat1, lon1, lat2, lon2):

    # Mean latitude (important!)
    lat_avg = math.radians((lat1 + lat2) / 2)

    # Feet per degree
    feet_per_deg_lat = 364000  # ~111,000 meters
    feet_per_deg_lon = feet_per_deg_lat * math.cos(lat_avg)

    dx = (lon2 - lon1) * feet_per_deg_lon
    dy = (lat2 - lat1) * feet_per_deg_lat

    return math.hypot(dx, dy)/5280
def distance_from_quad(lat, lon):
    return local_distance_mi(lat, lon, 41.78955556, -87.59963889)

def is_prime(n):
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False

    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6

    return True

```


```{python setup_py1, exercise = TRUE, exercise.eval=FALSE, message=FALSE}
import numpy as np
import pandas as pd

uni_directory = pd.read_csv("data/university_directory.csv").iloc[:, 0:4]
uni_directory.sample(5)
```

## List comprehensions

As we mentioned earlier comprehensions are in essence a shorter way to do a for loop. In the below example we make a list of all numbers divisible by 2 and 3 using a for loop. 

```{python first_example_list, exercise=TRUE}
loop_list = [] # creating a empty list
for i in np.arange(1, 26): # i takes on each value in np.arange(1, 26)
  # only add to the list if divisble by 2 & 3
  if((i % 2) == 0) and ((i % 3) == 0):
    loop_list.append(i) # updating the list
loop_list
```

Here is the equivalent way to accomplish this task with a list comprehension.

```{python first_example_comprehension, exercise = TRUE}
comp_list = [i for i in np.arange(1, 26) if ((i % 2) == 0) and ((i % 3) == 0)]
comp_list
```

```{r q1_discussion, context="server"}
q1_hint_visible <- reactiveVal(FALSE)
output$q1_plot_output <- renderUI({
    tagList(
      p("Discuss with a partner or on edStem about at least one of the following prompts."),
      actionButton("q1_show_hint_btn", "ðŸ’¡ Show discussion"),
      tags$div(
        id = "q1_hint_box",
        class="discussionbox",
        style = paste(
          if (!q1_hint_visible()) "display:none;" else "",
          "margin-top:.6px; border:1px solid #ddd; padding:.20px; border-radius:.5px;"
        ),
        tags$div(
        class = "center",
        tags$strong("Discuss with a neighbor (or on Ed):")
        ),
        tags$ol(
        tags$li("What are the major differences between the for loop and list comprehension examples above syntactically?"),
         tags$li("What parts seem to be the same for both for statements?"),
         tags$li("What are your initial guesses about when you personally would prefer one over the other?")
     )
    )
    )
})

observeEvent(input$q1_show_hint_btn, {
  shinyjs::toggle(id = "q1_hint_box", anim = TRUE, time = 0.2)
  q1_hint_visible(!q1_hint_visible())
  updateActionButton(
    session, "q1_show_hint_btn",
    label = if (q1_hint_visible()) "ðŸ™ˆ Hide discussion" else "ðŸ’¡ Show discussion"
  )
})
```

```{r q1_discussion_output, echo=FALSE, eval=TRUE, message = FALSE, warning = FALSE}
uiOutput("q1_plot_output")
```

Now that we've given some thought to the difference in style between the two types of loops lets break down the exact syntax for list comprehensions.

Each list comprehension has a version of the following syntax:
`[expression for item in iterable if condition]`.

If you want to iterate through two different things at once you can do so with
`[expression for item_1 in iterable_1 for item_2 in iterable_2 if condition]`

And if you wanted two conditions you simply adjust the above so it reads 
`[expression for item_1 in iterable_1 for item_2 in iterable_2 if condition_1 if condition_2]`

As you can tell list comprehensions are an extremely flexible and concise way to make lists. Below we'll go through some more examples where you'll start making your own list comprehensions.

```{r q1, echo=FALSE}
question("1. If you wanted to change our initial example so that it would instead get all numbers divisible by both 2 and 4 between 1 and 25 which of the following parts of the list comprehension would you have to change?",
         answer("`i for i`", correct=FALSE),
         answer("`in np.arange(1,26)`",message="Our range of possible values is not changing here only which subset of numbers in the range we want to include!", correct=FALSE),
         answer("`((i % 2) == 0) and ((i % 3) == 0)`", message="Correct! Changing the conditional is the same as in the for loop approach it's just in a different place now.", correct=TRUE),
         answer("No need to change anything at all!", correct=FALSE, message="Since the condition changes we need to adjust the code so the new condition is met!"),
        allow_retry = TRUE,
        post_message = "Congratulations! You have found the 1st secret word: CONDITIONAL",
  random_answer_order = TRUE)
```

Question 2. Fill in the blank below to make a list comprehension that is equivalent to the following for loop which puts the squares of the first 10 numbers in a list.
```
empty_list = []
for i in range(1,11):
  empty_list.append(i**2)
```

```{python q2, exercise=TRUE}
list_of_squares = ...
list_of_squares
```

```{python q2-solution, echo=FALSE}
list_of_squares = [i**2 for i in range(1, 11)]
list_of_squares
```

```{r q2-check, context="server"}
grade_this({
  if (is.null(.result)) {
    fail("Replace the `...` with your answer and make sure the last line is `list_of_squares`.")
  }

  res <- reticulate::py_to_r(.result)
  
  if (isTRUE(all.equal(res, c(1, 4, 9, 16, 25, 36, 49, 64, 81, 100)))) {
    pass("Nice work! You correctly made the list comprehension.")
  } else {
    fail(paste0(
      "I expected `\"[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\"`, but got `\"",
      paste0("[", paste(res, collapse = ", "), "]"),
      "\"` instead."
    ))
  }
})
```

Now we'll start considering conditions.

Question 3. Using a list comprehension assign short names to a list of the abbreviations of campus buildings which have a abbreviation that's less than 3 characters 

```{python q3, exercise=TRUE}
abbr = uni_directory.iloc[:, 0]
short_names = ...
short_names
```

```{python q3-solution, echo=FALSE}
abbr = uni_directory.iloc[:, 0]
short_names = [abb for abb in abbr if len(abb) < 3]
short_names
```

```{r q3-check, context="server"}
grade_this({
  if (is.null(.result)) {
    fail("Replace the `...` with your answer and make sure the last line is `short_names`.")
  }

  res <- reticulate::py_to_r(.result)
  
  if (isTRUE(all.equal(res, c('A', 'AB', 'BG', 'C', 'CL', 'E', 'ED', 'F', 'GC', 'H', 'HC', 'HM', 'K', 'LC', 'M', 'MS', 'OR', 'P', 'RO', 'RY', 'S', 'SS', 'TH', 'W', 'WB', 'Y', 'Z')))) {
    pass("Nice work! You correctly made the list comprehension.")
  } else {
    fail(paste0(
      "I expected `\"['A', 'AB', 'BG', 'C', 'CL', 'E', 'ED', 'F', 'GC', 'H', 'HC', 'HM', 'K', 'LC', 'M', 'MS', 'OR', 'P', 'RO', 'RY', 'S', 'SS', 'TH', 'W', 'WB', 'Y', 'Z']\"`, but got `\"",
      paste0("[", paste(res, collapse = ", "), "]"),
      "\"` instead."
    ))
  }
})
```

Before we continue we want to introduce the `enumerate` utility function. The `enumerate` function takes in a single iterable and returns an iterable of tuples where the first element of each iterable is the "index" of the input to the function and the second element is just the original element passed into the function at that "index". That explanation seems a little confusing but the concept will hopefully be clear with the below example.

```{python enumerate-example, exercise=TRUE}
for i, elem in enumerate(["red", "orange", "yellow", "green", "blue", "indigo", "violet"]):
  print("The", i, " element in the list is ", elem)
```

Question 4. Take advantage of our new knowledge to assign `every_even_R_name` to a list which contains the names of all buildings that start with R and have an even index.

```{python q4, exercise=TRUE}
names = uni_directory.iloc[:, 1]
every_even_R_name = ...
every_even_R_name
```

```{python q4-solution, echo=FALSE}
names = uni_directory.iloc[:, 1]
every_even_R_name = [name for i, name in enumerate(names) if name[0] == "R" if i%2 == 0]
every_even_R_name
```

```{r q4-check, context="server"}
grade_this({
  if (is.null(.result)) {
    fail("Replace the `...` with your answer and make sure the last line is `every_even_R_name`.")
  }

  res <- reticulate::py_to_r(.result)
  
  if (isTRUE(all.equal(res, c('Reva and David Logan Center for the Arts, 915 E. 60th St.', 'Rockefeller Memorial Chapel, 5850 S. Woodlawn Ave.', 'Ryerson Physical Laboratory, 1100 E. 58th St., Chicago')))) {
    pass("Nice work! You correctly made the list comprehension.")
  } else {
    fail(paste0(
      "I expected `\"['Reva and David Logan Center for the Arts, 915 E. 60th St.', 'Rockefeller Memorial Chapel, 5850 S. Woodlawn Ave.', 'Ryerson Physical Laboratory, 1100 E. 58th St., Chicago']\"`, but got `\"",
      paste0("[", paste(res, collapse = ", "), "]"),
      "\"` instead."
    ))
  }
})
```

Use this matrix in the following question.

```{python list-of-lists, exercise=TRUE}
matrix = np.array([[1, 4, 7], [2, 5, 8], [3, 6, 9]])
matrix
```

```{r q5, echo=FALSE}
question("5. Which of the following list comprehensions correctly get all the elements above or along the diagonal of the matrix",
         answer("`[matrix[i, j] for i in range(matrix.shape[0]) for j in range(i, matrix.shape[0]) if j >= i ]`", message="Correct, great job navigating the indexes.", correct=TRUE),
         answer("`[matrix[i, j] for i in range(matrix.shape[0]) for j in range(i, matrix.shape[0]) if i >= j ]`", correct=FALSE),
         answer("`[matrix[i, j] for i in range(matrix.shape[0]) for j in range(matrix.shape[0])]`", correct=FALSE),
         answer("`[matrix[i][j] for i in range(matrix.shape[0]) for j in range(i, matrix.shape[0]) if i >= j]`", correct=FALSE),
        allow_retry = TRUE,
        post_message = "Congratulations! You have found the 2nd secret word: MAGIC",
  random_answer_order = TRUE)
```

Note while list comprehensions works great here we shouldn't always use them just because we can. In this case `matrix[np.triu_indices(3)]` which takes advantage of a numpy function would work as well.


:::: {.discussionbox}
::: {.center}
**Before continuing take a moment to consider
with a neighbor (or on Ed):**
:::
When does it make sense to use a list comprehension rather than a standard `for` loop. What are the pros and cons of each approach?
::::

- todo: add hints

## Dictionary Comprehensions

Comprehensions are not just for lists! In this section we'll be showing you how you can do dictionary comprehensions as well. Before we start that though a quick reminder about what a dictionary is and how to manipulate one. If you don't need it feel free to skip to the example dictionary comprehension below.

### Dictionaries Review
Each dictionary is composed of a series of (key, value) pairs. Each key can be any immutable data type with the most common being strings or occasionally ints or booleans. On the other hand each value can be any data type. The most common way to construct a dictionary is by wrapping key value pairs inside curly brackets `{key : value}` like so. For instance, below is an example of a simple dictionary representing basic info about the Chicago Cubs Franchise as of 2025.

```{python cubs_example, exercise=TRUE}
cubs_dict = {"Team Name": "Cubs", "Championships": 3, "Mascot": "Clark the Cub", "Founded": 1876, "In National League": True, "Winning %": 0.513}
cubs_dict
```
We can access values in dictionaries by their keys with the syntax `dict_name[key]`. We can also add or update values by their keys with the syntax `dict_name[key] = new_value`. So if we wanted to imagine the Cubs win the championship this year we could update the championship value then update it as you see below.

```{python cubs_example_continued, exercise=TRUE, setup='cubs_example'}
cubs_dict["Championships"] = 4
cubs_dict["Championships"]
```
If we want to iterate through a dictionary we have a number of options. `dict.keys()` gives the keys, `dict.values()` gives the values, and `dict.items()` to give a collection of tuples containing the key:value pairs. If we just put the dictionary name as the iterable in a `for` loop it's equivalent to giving `dict.keys()`. With that here is an example iterating through our example cubs_dictionary.
```{python cubs_example_iter, exercise=TRUE, setup='cubs_example_continued'}
for key, value in cubs_dict.items():
  print(f"The value of the {key} key is {value}!")
```

### A Brief Aside on `Zip`
Before we continue we want to quickly introduce the `zip` utility function. Just like the `enumerate` function earlier `zip` is often used to make iteration easier. `zip` takes in 0 or more iterables of the same size and packages each element in order into a collection of tuples. So `zip([1, 2, 3, 4], [5, 6, 7, 8])` will give `zip_object((1, 5), (2, 6), (3, 7), (4,8))`. 

For now don't worry about what a zip object is other than knowing you can iterate through one. If you want to learn more check out zip's [documentation](https://docs.python.org/3/library/functions.html).

In this example you'll quickly see how zip can be useful. We want to make a dictionary of the abbreviations and building names in our `uni_directory` dataset. Below you'll see how we can do it with a for loop and with a dictionary comprehensions!
```{python first_dictcomp_example, exercise=TRUE}
# getting the columns as variables. not stricly neccessary
abbrs = uni_directory['Acronym']
names = uni_directory['Original Address']
abbr_to_names = {} # initializing an empty dictionary
# iterating through both columns together with zip
for abbr, name in zip(abbrs, names):
  abbr_to_names[abbr] = name # updating the dictionary
print("With a for loop!")
print(abbr_to_names)
print("With a dict comprehensions!")
print({name : abbr for name, abbr in zip(abbrs, names)})
print(f"The abbreviation for {abbr_to_names['E']} is E")
```

6. As you can see this dictionary was quite large. Let's cut it down by making the part before the comma of each building name the key and the acronym the value. Assign `names_to_abbr` to such a dictionary using a dictionary comprehension.

```{python q6, exercise=TRUE, setup="first_dictcomp_example"}
names_to_abbr = ...
names_to_abbr
```

```{python q6-hint, echo=FALSE}
# "string, string2".split(",") returns ["string", "string2"]
```

```{python q6-solution, echo=FALSE}
names_to_abbr = {name.split(",")[0]: abbr for abbr, name in abbr_to_names.items()}
names_to_abbr
```

```{r q6-check, context="server"}
grade_this({
  if (is.null(.result)) {
    fail("Replace the `...` with your answer and make sure the last line is `names_to_abbr`.")
  }

  # Convert Python dict to R named vector
  res <- reticulate::py_to_r(.result)

  # Define expected output as a named list to match what res is
  expected <- as.list(c(
    '1155 E 60th St' = '1155',
    'Anatomy Building' = 'A',
    'Abbott Memorial Hall' = 'AB',
    'Art Institute of Chicago' = 'ART INT',
    'Booth 455' = 'B455',
    'Bartlett Commons' = 'BG',
    'Billings' = 'BH A',
    'Biological Sciences Learning Center' = 'BSLC',
    'Ben May Institute' = 'BMI',
    'Cobb Lecture Hall' = 'C',
    'Chapin Hall' = 'CHAP',
    'Classics Building-Hiram Kelly Memorial' = 'CL',
    'Cummings Life Science Center' = 'CLSC',
    'Campus North Residential Commons' = 'CNRC',
    'Cochrane-Woods Art Center' = 'CWAC',
    'David and Alfred Smart Museum' = 'DASM',
    'Eckhart Hall' = 'E',
    'Ida B. and Walter Erman Biology Center' = 'EBC',
    'Edelstone Center' = 'ED',
    'William Eckhardt Research Center' = 'ERC',
    'Foster Hall' = 'F',
    'Field Museum of Natural History' = 'FMNH',
    'Gates-Blake Halls' = 'G-B',
    'George Herbert Jones Laboratory' = 'GHJ',
    'Gleacher Center' = 'GC',
    'Gordon Center for Integrative Science' = 'GCIS',
    'Goodspeed Hall' = 'GO H',
    'Ctrs for Gender Studies and Race' = 'GSRP',
    'Haskell Hall' = 'H',
    'The University of Chicago Booth School of Business Charles M. Harper Center' = 'HC',
    'Henry Hinds Laboratory for the Geophysical Sciences' = 'HGS',
    'William Rainey Harper Memorial Library' = 'HM',
    'Institute on the Formation of Knowledge' = 'IFK',
    'John Crerar Library' = 'JCL',
    'Joseph Regenstein Library' = 'JRL',
    'Kent Chemical Laboratory' = 'K',
    'Kersten Physics Teaching Center' = 'KPTC',
    'Laird Bell Quadrangle' = 'LBQ',
    'Reva and David Logan Center for the Arts' = 'LC',
    'Midway Studios' = 'M',
    'MS Math-Stat Building' = 'MS',
    'Institute for the Study of Ancient Cultures' = 'OR',
    'Albert Pick Hall for International Studies' = 'P',
    'Psychology Beecher Hall' = 'PSY B',
    'Psychology Green Hall' = 'PSY G',
    'Psychology' = 'PSY K',
    'Rockefeller Memorial Chapel' = 'RMC',
    'Rosenwald Hall' = 'RO',
    'Ryerson Physical Laboratory' = 'RY',
    'Swift Hall' = 'S',
    'Searle Chemistry Laboratory' = 'SCL',
    'Saieh Hall for Economics' = 'SHFE',
    'Social Sciences Research Building' = 'SS',
    'Edith Abbott Hall' = 'SSA',
    '950 E. 61st St.' = 'SSC',
    'Harold Leonard Stuart Hall' = 'STU',
    'Lorado Taft House' = 'TH',
    'Toyota Technical Institute at Chicago' = 'TTI',
    'Walker Museum' = 'W',
    'Wieboldt Hall' = 'WB',
    'Young Memorial Building' = 'Y',
    'Zoology Building' = 'Z'
  ))
  
  if (isTRUE(all.equal(res, expected))) {
    pass("Nice work! You correctly created the dictionary of building abbreviations. Your third secret word is: NAMES")
  } else {
    fail("Your dictionary does not match the expected building names and abbreviations.")
  }
})
```

Before we continue lets break down the exact syntax for dictionary comprehensions.

Each dictionary comprehension has a version of the following syntax:
`{key : value for item in iterable if condition}`.

Similar to the list comprehension you can do more complicated ones like the general syntax below.

`{key:value for item_1 in iterable_1 for item_2 in iterable_2 if condition_1 if condition_2}`

:::: {.discussionbox}
::: {.center}
**Before continuing take a moment to consider
with a neighbor (or on Ed):**
:::
When does it make sense to use a dictionary comprehension rather than a standard `for` loop. What are the pros and cons of each approach?
::::

```{r q7, echo=FALSE}
question("7. How many keys will the following dictionary have `{key : value for key in range(1,5) for value in range(6,10)}`",
         answer("4", message="Yes, earlier values of each key will be erased", correct=TRUE),
         answer("5", correct=FALSE),
         answer("15", correct=FALSE),
         answer("16", correct=FALSE),
         answer("Error because dictionaries can't have duplicate keys", correct=FALSE, message="While you're right dictionaries can't have duplicate keys this example will keep overwriting the earlier values for each key!"),
         allow_retry = TRUE,
  random_answer_order = TRUE)
```


Below we'll go through some more examples where you'll continue making your own dictionary comprehensions and see how combining functions and `zip` can make them quite powerful.

8. Remember, integers can be keys too! To demonstrate this assign last_digit_of_prime to a dictionary where the keys are the prime numbers between 1-99 and the values are the last digit of each one. To help you out you can use the `is_prime(n)` function which has been predefined for you which takes in a number and returns the boolean True if it's a prime.

```{python q8, exercise=TRUE}
last_digit_of_prime = ...
last_digit_of_prime
```

```{python q8-solution, echo=FALSE}
last_digit_of_prime = {n : n%10 for n in range(1, 100) if is_prime(n)}
last_digit_of_prime
```

```{r q8-check, context="server"}
grade_this({
  if (is.null(.result)) {
    fail("Replace the `...` with your answer and make sure the last line is `names_to_abbr`.")
  }

  # Convert Python dict to R named vector
  res <- reticulate::py_to_r(.result)

  # Define expected output as a named list to match what res is
  expected <- list(
  "2"  = 2,
  "3"  = 3,
  "5"  = 5,
  "7"  = 7,
  "11" = 1,
  "13" = 3,
  "17" = 7,
  "19" = 9,
  "23" = 3,
  "29" = 9,
  "31" = 1,
  "37" = 7,
  "41" = 1,
  "43" = 3,
  "47" = 7,
  "53" = 3,
  "59" = 9,
  "61" = 1,
  "67" = 7,
  "71" = 1,
  "73" = 3,
  "79" = 9,
  "83" = 3,
  "89" = 9,
  "97" = 7
)

  
  if (isTRUE(all.equal(res, expected))) {
    pass("Nice work! You correctly created the dictionary of prime numbers and their last digit correctly.")
  } else {
    fail("Your dictionary does not match the expected primes.")
  }
})
```

```{r q9, echo=FALSE}
question("9. Which of the following dictionary comprehensions correctly make a dictionary where the keys are the name of the building before the comma and the keys are their distance to Ryerson? You can assume `local_distance_mi(lat1, lon1,41.78968700	-87.59820100)` correctly calculates the distance.",
         answer("`{name.split(',')[0]: local_distance_mi(lat, lon, 1.78968700	-87.59820100) for name, lat, lon in zip(names, uni_directory.iloc[:, 2], uni_directory.iloc[:, 3])}`", message="... now where is Ryerson Annex?", correct=TRUE),
         answer("`{name: local_distance_mi(lat, lon, 1.78968700	-87.59820100) for name, lat, lon in zip(names, uni_directory.iloc[:, 2], uni_directory.iloc[:, 3])}`", correct=FALSE),
         answer("`{local_distance_mi(lat, lon, 1.78968700	-87.59820100): name for name, lat, lon in zip(names, uni_directory.iloc[:, 2], uni_directory.iloc[:, 3])}`", correct=FALSE),
         answer("`{name.split(',')[0]: local_distance_mi(lat, lon, 1.78968700	-87.59820100) for name, lat, lon in (names, uni_directory.iloc[:, 2], uni_directory.iloc[:, 3])}`", correct=FALSE),
         answer("`{name.split(',')[0]: local_distance_mi(lat, lon, 1.78968700	-87.59820100) for name in names for lat in  uni_directory.iloc[:, 2] for lon in uni_directory.iloc[:, 3]}`", correct=FALSE),
        allow_retry = TRUE,
        post_message = "Congratulations! You have found the 4th secret word: RYERSON",
  random_answer_order = TRUE)
```

10. Using a dictionary comprehension assign `close_to_the_quad` to a dictionary containing the first part of each building name (before the comma) as the key and the value as the buildings distance rounded to two decimal places to the center of the main quadrangle. Only include buildings which are less than a quarter mile from the center of the quad. To help you we've predefined the function `distance_from_quad(lat, lon)` to compute any buildings distance to the quad.

```{python q10, exercise=TRUE}
close_to_the_quad = ...
close_to_the_quad
```

```{python q10-solution, echo=FALSE}
close_to_the_quad = {
  name.split(",")[0]: round(distance_from_quad(lat, lon), 2)
  for name, lat, lon in zip(uni_directory.iloc[:, 1], uni_directory.iloc[:, 2], uni_directory.iloc[:, 3]) if distance_from_quad(lat, lon) < 0.25
  }
close_to_the_quad
```

```{r q10-check, context="server"}
grade_this({
  if (is.null(.result)) {
    fail("Replace the `...` with your answer and make sure the last line is `names_to_abbr`.")
  }

  # Convert Python dict to R named vector
  res <- reticulate::py_to_r(.result)

  # Define expected output as a named list to match what res is
  expected <- list(
  'Anatomy Building' = 0.09,
  'Bartlett Commons' = 0.18,
  'Billings' = 0.15,
  'Biological Sciences Learning Center' = 0.22,
  'Ben May Institute' = 0.18,
  'Cobb Lecture Hall' = 0.09,
  'Classics Building-Hiram Kelly Memorial' = 0.13,
  'Cummings Life Science Center' = 0.14,
  'Eckhart Hall' = 0.08,
  'Ida B. and Walter Erman Biology Center' = 0.09,
  'William Eckhardt Research Center' = 0.2,
  'Foster Hall' = 0.13,
  'Gates-Blake Halls' = 0.11,
  'George Herbert Jones Laboratory' = 0.07,
  'Gordon Center for Integrative Science' = 0.21,
  'Goodspeed Hall' = 0.12,
  'Ctrs for Gender Studies and Race' = 0.12,
  'Haskell Hall' = 0.09,
  'The University of Chicago Booth School of Business Charles M. Harper Center' = 0.21,
  'Henry Hinds Laboratory for the Geophysical Sciences' = 0.12,
  'William Rainey Harper Memorial Library' = 0.11,
  'Institute on the Formation of Knowledge' = 0.11,
  'John Crerar Library' = 0.18,
  'Joseph Regenstein Library' = 0.18,
  'Kent Chemical Laboratory' = 0.06,
  'Kersten Physics Teaching Center' = 0.14,
  'MS Math-Stat Building' = 0.13,
  'Institute for the Study of Ancient Cultures' = 0.1,
  'Albert Pick Hall for International Studies' = 0.08,
  'Psychology Beecher Hall' = 0.12,
  'Psychology Green Hall' = 0.12,
  'Psychology' = 0.12,
  'Rockefeller Memorial Chapel' = 0.15,
  'Rosenwald Hall' = 0.05,
  'Ryerson Physical Laboratory' = 0.07,
  'Swift Hall' = 0.05,
  'Searle Chemistry Laboratory' = 0.1,
  'Saieh Hall for Economics' = 0.11,
  'Social Sciences Research Building' = 0.11,
  'Harold Leonard Stuart Hall' = 0.08,
  'Walker Museum' = 0.06,
  'Wieboldt Hall' = 0.11,
  'Zoology Building' = 0.12
)

  
  if (isTRUE(all.equal(res, expected))) {
    pass("Nice work! You correctly created the dictionary of buildings near the quad and their distances.")
  } else {
    fail("Your dictionary does not match the expected buildings and distances")
  }
})
```


## Set Comprehensions

## Extra Practice
  

